import jsPDF from 'jspdf'
import html2canvas from 'html2canvas'

export interface CaseSummaryData {
  totalItems: number
  totalValue: number
  evidenceCount: number
  itemsWithPhotos: number
  itemsWithVideos: number
  itemsWithDocuments: number
  categories: { [key: string]: number }
  dateRange: { earliest: string; latest: string }
  topItemsByValue: Array<{
    id: number
    name: string
    estimatedValue: number
    category: string
  }>
  evidenceTypes: { [key: string]: number }
  generatedBy: string
  generatedAt: string
  caseName?: string
}

export interface EvidenceTagsData {
  tagCategories: Array<{
    id: string
    name: string
    color: string
    description: string
    items: Array<{
      id: number
      name: string
      estimatedValue: number
      category: string
      description: string
      dateLastSeen: string
      evidence: Array<{
        type: string
        filename: string | null
      }>
    }>
  }>
  totalItems: number
  totalEvidence: number
  generatedBy: string
  generatedAt: string
  caseName?: string
}

// Helper function to clean text for PDF compatibility
const cleanTextForPDF = (text: string): string => {
  return text
    .replace(/[^\w\s\-$.,():]/g, '') // Remove special characters except basic punctuation
    .replace(/\s+/g, ' ') // Normalize whitespace
    .trim()
}

export async function generateCaseSummaryPDF(
  data: CaseSummaryData,
  elementRef?: HTMLElement
): Promise<void> {
  const pdf = new jsPDF('p', 'mm', 'a4')
  const pageWidth = pdf.internal.pageSize.getWidth()
  const pageHeight = pdf.internal.pageSize.getHeight()
  let yPosition = 20

  // Helper function to add text with word wrapping
  const addText = (text: string, x: number, y: number, options: any = {}) => {
    const { fontSize = 10, fontStyle = 'normal', color = '#000000', maxWidth = pageWidth - 40 } = options
    pdf.setFontSize(fontSize)
    pdf.setFont('helvetica', fontStyle)
    pdf.setTextColor(color)
    
    const cleanText = cleanTextForPDF(text)
    const lines = pdf.splitTextToSize(cleanText, maxWidth)
    pdf.text(lines, x, y)
    return y + (lines.length * (fontSize * 0.4))
  }

  // Helper function to add a section header
  const addSectionHeader = (title: string, x: number, y: number) => {
    // Clean title of any special characters that might cause encoding issues
    const cleanTitle = title.replace(/[^\w\s-]/g, '').trim()
    pdf.setFillColor(220, 38, 38) // Red background
    pdf.rect(x, y - 5, pageWidth - 40, 8, 'F')
    pdf.setTextColor(255, 255, 255) // White text
    pdf.setFontSize(12)
    pdf.setFont('helvetica', 'bold')
    pdf.text(cleanTitle, x + 2, y + 2)
    pdf.setTextColor(0, 0, 0) // Reset to black
    return y + 12
  }

  // Helper function to add a metric box
  const addMetricBox = (label: string, value: string, x: number, y: number, color: number[]) => {
    const boxWidth = 40
    const boxHeight = 20
    
    pdf.setFillColor(color[0], color[1], color[2])
    pdf.rect(x, y, boxWidth, boxHeight, 'F')
    
    pdf.setTextColor(255, 255, 255)
    pdf.setFontSize(10)
    pdf.setFont('helvetica', 'bold')
    pdf.text(cleanTextForPDF(value), x + 2, y + 8)
    
    pdf.setTextColor(255, 255, 255)
    pdf.setFontSize(8)
    pdf.setFont('helvetica', 'normal')
    pdf.text(cleanTextForPDF(label), x + 2, y + 16)
    
    return x + boxWidth + 5
  }

  try {
    // Header
    pdf.setFillColor(153, 27, 27) // Dark red
    pdf.rect(0, 0, pageWidth, 30, 'F')
    
    pdf.setTextColor(255, 255, 255)
    pdf.setFontSize(20)
    pdf.setFont('helvetica', 'bold')
    pdf.text('CASE SUMMARY REPORT', 20, 20)
    
    pdf.setFontSize(10)
    pdf.setFont('helvetica', 'normal')
    pdf.text(`Generated by: ${cleanTextForPDF(data.generatedBy)}`, 20, 25)
    pdf.text(`Generated on: ${cleanTextForPDF(data.generatedAt)}`, 20, 28)
    
    yPosition = 40

    // Case Overview Section
    yPosition = addSectionHeader('CASE OVERVIEW', 20, yPosition)
    
    // Metrics boxes
    let xPos = 20
    xPos = addMetricBox('Stolen Items', data.totalItems.toString(), xPos, yPosition, [220, 38, 38])
    xPos = addMetricBox('Total Value', `$${data.totalValue.toLocaleString()}`, xPos, yPosition, [5, 150, 105])
    xPos = addMetricBox('Evidence Files', data.evidenceCount.toString(), xPos, yPosition, [124, 58, 237])
    xPos = addMetricBox('Items w/ Photos', data.itemsWithPhotos.toString(), xPos, yPosition, [217, 119, 6])
    
    yPosition += 30

    // Evidence Analysis Section
    yPosition = addSectionHeader('EVIDENCE ANALYSIS', 20, yPosition)
    
    if (Object.keys(data.evidenceTypes).length > 0) {
      Object.entries(data.evidenceTypes).forEach(([type, count]) => {
        yPosition = addText(`${type.charAt(0).toUpperCase() + type.slice(1)}: ${count} files`, 25, yPosition)
      })
    } else {
      yPosition = addText('No evidence files found', 25, yPosition)
    }
    
    yPosition += 10

    // Categories Section
    yPosition = addSectionHeader('ITEM CATEGORIES', 20, yPosition)
    
    if (Object.keys(data.categories).length > 0) {
      Object.entries(data.categories).forEach(([category, count]) => {
        yPosition = addText(`${category}: ${count} items`, 25, yPosition)
      })
    } else {
      yPosition = addText('No categories found', 25, yPosition)
    }
    
    yPosition += 10

    // Timeline Section
    yPosition = addSectionHeader('INCIDENT TIMELINE', 20, yPosition)
    yPosition = addText(`Earliest Incident: ${data.dateRange.earliest}`, 25, yPosition)
    yPosition = addText(`Latest Incident: ${data.dateRange.latest}`, 25, yPosition)
    
    yPosition += 10

    // High-Value Items Section
    yPosition = addSectionHeader('HIGH-VALUE ITEMS', 20, yPosition)
    
    if (data.topItemsByValue.length > 0) {
      data.topItemsByValue.forEach((item, index) => {
        const itemText = `${index + 1}. ${item.name} - $${item.estimatedValue.toLocaleString()}`
        yPosition = addText(itemText, 25, yPosition)
        if (item.category) {
          yPosition = addText(`   Category: ${item.category}`, 25, yPosition)
        }
        yPosition += 2
      })
    } else {
      yPosition = addText('No high-value items found', 25, yPosition)
    }

    // Footer
    const footerY = pageHeight - 20
    pdf.setFontSize(8)
    pdf.setFont('helvetica', 'normal')
    pdf.setTextColor(128, 128, 128)
    pdf.text('Generated by Crime Report System', 20, footerY)
    pdf.text(`Page 1 of 1`, pageWidth - 30, footerY)

    // Save the PDF
    const fileName = `case-summary-${data.caseName || 'report'}-${new Date().toISOString().split('T')[0]}.pdf`
    pdf.save(fileName)

  } catch (error) {
    console.error('Error generating PDF:', error)
    throw new Error('Failed to generate PDF report')
  }
}

export async function generateEvidenceTagsPDF(data: EvidenceTagsData): Promise<void> {
  const pdf = new jsPDF('p', 'mm', 'a4')
  const pageWidth = pdf.internal.pageSize.getWidth()
  const pageHeight = pdf.internal.pageSize.getHeight()
  let yPosition = 20

  // Helper function to add text with word wrapping
  const addText = (text: string, x: number, y: number, options: any = {}) => {
    const { fontSize = 10, fontStyle = 'normal', color = '#000000', maxWidth = pageWidth - 40 } = options
    pdf.setFontSize(fontSize)
    pdf.setFont('helvetica', fontStyle)
    pdf.setTextColor(color)
    
    const cleanText = cleanTextForPDF(text)
    const lines = pdf.splitTextToSize(cleanText, maxWidth)
    pdf.text(lines, x, y)
    return y + (lines.length * (fontSize * 0.4))
  }

  // Helper function to add a section header
  const addSectionHeader = (title: string, x: number, y: number) => {
    const cleanTitle = cleanTextForPDF(title)
    pdf.setFillColor(220, 38, 38) // Red background
    pdf.rect(x, y - 5, pageWidth - 40, 8, 'F')
    pdf.setTextColor(255, 255, 255) // White text
    pdf.setFontSize(12)
    pdf.setFont('helvetica', 'bold')
    pdf.text(cleanTitle, x + 2, y + 2)
    pdf.setTextColor(0, 0, 0) // Reset to black
    return y + 12
  }

  // Helper function to add a category header
  const addCategoryHeader = (category: any, x: number, y: number) => {
    const categoryWidth = pageWidth - 40
    const headerHeight = 10
    
    // Category background with color
    const colorRgb = hexToRgb(category.color)
    pdf.setFillColor(colorRgb.r, colorRgb.g, colorRgb.b)
    pdf.rect(x, y, categoryWidth, headerHeight, 'F')
    
    // Category name and count
    pdf.setTextColor(255, 255, 255)
    pdf.setFontSize(11)
    pdf.setFont('helvetica', 'bold')
    const categoryText = `${cleanTextForPDF(category.name)} (${category.items.length} items)`
    pdf.text(categoryText, x + 2, y + 7)
    
    // Description
    pdf.setTextColor(200, 200, 200)
    pdf.setFontSize(8)
    pdf.setFont('helvetica', 'normal')
    pdf.text(cleanTextForPDF(category.description), x + 2, y + 9.5)
    
    return y + headerHeight + 5
  }

  // Helper function to convert hex to RGB
  const hexToRgb = (hex: string) => {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : { r: 220, g: 38, b: 38 }
  }

  // Helper function to add item entry
  const addItemEntry = (item: any, x: number, y: number, index: number) => {
    const indent = 5
    const itemY = y + (index * 15)
    
    // Item name and value
    pdf.setTextColor(0, 0, 0)
    pdf.setFontSize(9)
    pdf.setFont('helvetica', 'bold')
    const itemText = `${index + 1}. ${cleanTextForPDF(item.name)}`
    pdf.text(itemText, x + indent, itemY)
    
    // Value on the right
    pdf.setTextColor(5, 150, 105) // Green for value
    const valueText = `$${item.estimatedValue.toLocaleString()}`
    pdf.text(valueText, pageWidth - 50, itemY)
    
    // Category and date
    pdf.setTextColor(100, 100, 100)
    pdf.setFontSize(7)
    pdf.setFont('helvetica', 'normal')
    const detailsText = `${item.category} â€¢ ${item.dateLastSeen}`
    pdf.text(cleanTextForPDF(detailsText), x + indent + 2, itemY + 4)
    
    // Evidence count if available
    if (item.evidence && item.evidence.length > 0) {
      pdf.setTextColor(124, 58, 237) // Purple for evidence
      const evidenceText = `${item.evidence.length} evidence files`
      pdf.text(cleanTextForPDF(evidenceText), x + indent + 2, itemY + 7)
    }
    
    return itemY + 10
  }

  try {
    // Header
    pdf.setFillColor(153, 27, 27) // Dark red
    pdf.rect(0, 0, pageWidth, 30, 'F')
    
    pdf.setTextColor(255, 255, 255)
    pdf.setFontSize(20)
    pdf.setFont('helvetica', 'bold')
    pdf.text('EVIDENCE TAGS REPORT', 20, 20)
    
    pdf.setFontSize(10)
    pdf.setFont('helvetica', 'normal')
    pdf.text(`Generated by: ${cleanTextForPDF(data.generatedBy)}`, 20, 25)
    pdf.text(`Generated on: ${cleanTextForPDF(data.generatedAt)}`, 20, 28)
    
    yPosition = 40

    // Overview Section
    yPosition = addSectionHeader('OVERVIEW', 20, yPosition)
    yPosition = addText(`Total Items: ${data.totalItems}`, 25, yPosition)
    yPosition = addText(`Total Evidence Files: ${data.totalEvidence}`, 25, yPosition)
    yPosition = addText(`Categories: ${data.tagCategories.length}`, 25, yPosition)
    
    yPosition += 10

    // Categories Section
    yPosition = addSectionHeader('EVIDENCE CATEGORIES', 20, yPosition)
    
    data.tagCategories.forEach(category => {
      if (category.items.length > 0) {
        // Check if we need a new page
        const estimatedHeight = 15 + (category.items.length * 12) + 10
        if (yPosition + estimatedHeight > pageHeight - 30) {
          pdf.addPage()
          yPosition = 20
        }
        
        yPosition = addCategoryHeader(category, 20, yPosition)
        
        // Add items in this category
        category.items.forEach((item, index) => {
          yPosition = addItemEntry(item, 20, yPosition, index)
        })
        
        yPosition += 5
      }
    })

    // Summary Section
    yPosition = addSectionHeader('CATEGORY SUMMARY', 20, yPosition)
    data.tagCategories.forEach(category => {
      const summaryText = `${category.name}: ${category.items.length} items (${category.items.reduce((sum, item) => sum + item.estimatedValue, 0).toLocaleString()} total value)`
      yPosition = addText(summaryText, 25, yPosition)
    })

    // Footer
    const footerY = pageHeight - 20
    pdf.setFontSize(8)
    pdf.setFont('helvetica', 'normal')
    pdf.setTextColor(128, 128, 128)
    pdf.text('Generated by Crime Report System - Evidence Tags Module', 20, footerY)
    pdf.text(`Page 1 of 1`, pageWidth - 30, footerY)

    // Save the PDF
    const fileName = `evidence-tags-${data.caseName || 'report'}-${new Date().toISOString().split('T')[0]}.pdf`
    pdf.save(fileName)

  } catch (error) {
    console.error('Error generating Evidence Tags PDF:', error)
    throw new Error('Failed to generate Evidence Tags PDF report')
  }
}

export async function captureElementAsPDF(elementRef: HTMLElement, filename: string = 'case-summary.pdf'): Promise<void> {
  try {
    // Capture the element as canvas
    const canvas = await html2canvas(elementRef, {
      scale: 2,
      useCORS: true,
      allowTaint: true,
      backgroundColor: '#ffffff'
    })

    // Create PDF from canvas
    const imgData = canvas.toDataURL('image/png')
    const pdf = new jsPDF('p', 'mm', 'a4')
    const pageWidth = pdf.internal.pageSize.getWidth()
    const pageHeight = pdf.internal.pageSize.getHeight()
    
    // Calculate dimensions to fit the image
    const imgWidth = canvas.width
    const imgHeight = canvas.height
    const ratio = Math.min(pageWidth / imgWidth, pageHeight / imgHeight)
    const finalWidth = imgWidth * ratio
    const finalHeight = imgHeight * ratio
    
    // Center the image on the page
    const x = (pageWidth - finalWidth) / 2
    const y = (pageHeight - finalHeight) / 2
    
    pdf.addImage(imgData, 'PNG', x, y, finalWidth, finalHeight)
    pdf.save(filename)
    
  } catch (error) {
    console.error('Error capturing element as PDF:', error)
    throw new Error('Failed to capture element as PDF')
  }
}
